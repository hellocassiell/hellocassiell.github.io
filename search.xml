<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue3学习笔记</title>
      <link href="2021/07/20/vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/07/20/vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>对于熟悉vue2的小伙伴来说，如何在vue2的基础上快速全面地理解和掌握vue3呢？</p><blockquote><p>Q: 相对于vue2来说，vue3做了哪些改变?</p></blockquote><p>分为两个层面来说，一个是实现层面，一个是运用层面。</p><h2 id="实现层面"><a href="#实现层面" class="headerlink" title="实现层面"></a>实现层面</h2><h4 id="1-响应式原理的实现方式"><a href="#1-响应式原理的实现方式" class="headerlink" title="1. 响应式原理的实现方式"></a>1. 响应式原理的实现方式</h4><p>使用 proxy 代替 defineProperty（proxy不兼容IE）</p><blockquote><p>vue2的缺陷：<br>1 defineProperty无法监听数组方法变化，但是vue2对数组的八个方法做了hack<br>2 defineProperty可以监控数组下标变化，只是考虑到性能的问题，vue2放弃了这个特性，所以 <code>arr[1] = 3</code> 在vue2并不会触发数据更新<br>3 defineProperty无法监听数组长度变化<br>4 defineProperty无法检测到对象属性的新增或删除，vue2使用this.$set/this.$delete来解决</p></blockquote><h4 id="2-Diff算法的提升"><a href="#2-Diff算法的提升" class="headerlink" title="2. Diff算法的提升"></a>2. Diff算法的提升</h4><ul><li>将一个模板分成由结构指令分隔的嵌套“块”，当我们更新块中的节点时，我们不再需要递归遍历DOM树 - 该块内的动态绑定可以在一个平面数组中跟踪。</li><li>检测模板中的静态节点、子树甚至数据对象，在生成的代码中将它们提升到渲染函数之外。</li><li>为每个具有动态绑定的元素生成一个优化标志，运行时将获取这些标志提示并采用专用的快速路径。</li></ul><h4 id="3-更好的Tree-shaking"><a href="#3-更好的Tree-shaking" class="headerlink" title="3. 更好的Tree-shaking"></a>3. 更好的Tree-shaking</h4><p>一些全局API改为按需引入</p><h4 id="4-更好的Typescript支持"><a href="#4-更好的Typescript支持" class="headerlink" title="4. 更好的Typescript支持"></a>4. 更好的Typescript支持</h4><p>1 vue3是用TypeScript编写的库，可以享受到自动的类型定义提示<br>2 支持TSX</p><h2 id="运用层面"><a href="#运用层面" class="headerlink" title="运用层面"></a>运用层面</h2><h4 id="1-Composition-API"><a href="#1-Composition-API" class="headerlink" title="1. Composition API"></a>1. Composition API</h4><p>混入(mixin) 将不再作为推荐使用，Composition API可以实现更灵活且无副作用的复用代码。</p><ul><li>setup()</li><li>reactive、ref 与 toRefs</li><li>生命周期</li><li>watch 与 watchEffect<br>…</li></ul><h4 id="2-Fragment"><a href="#2-Fragment" class="headerlink" title="2. Fragment"></a>2. Fragment</h4><p>template中允许写多个根节点。</p><h4 id="3-Teleport"><a href="#3-Teleport" class="headerlink" title="3. Teleport"></a>3. Teleport</h4><p>可以将组件渲染的内容传送到任何指定的地方。</p><h4 id="4-Suspense"><a href="#4-Suspense" class="headerlink" title="4. Suspense"></a>4. Suspense</h4><p>异步请求组件。</p><blockquote><p>参考：<br><a href="https://juejin.cn/post/6940454764421316644">https://juejin.cn/post/6940454764421316644</a><br><a href="https://juejin.cn/post/6844904134303301645">https://juejin.cn/post/6844904134303301645</a><br><a href="https://juejin.cn/post/6976400439793172487">https://juejin.cn/post/6976400439793172487</a><br><a href="https://v3.vuejs.org/guide/composition-api-introduction.html#standalone-computed-properties">https://v3.vuejs.org/guide/composition-api-introduction.html#standalone-computed-properties</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试提问思路总结</title>
      <link href="2021/07/16/%E9%9D%A2%E8%AF%95%E6%8F%90%E9%97%AE%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
      <url>2021/07/16/%E9%9D%A2%E8%AF%95%E6%8F%90%E9%97%AE%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>面试问题我分为这么几大块：</p><p><code>1 基础 html、css、js</code></p><p><code>2 浏览器HTTP相关</code></p><p><code>3 框架/构建相关 （vue、react、node、webpack...）</code></p><p><code>4 手写代码 （常见算法、其他编程题）</code></p><p><code>5 性能优化</code></p><p>下面列举一些常见面试提问思路</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li><p>盒模型</p></li><li><p>flex:1 含义 → 适用场景</p></li><li><p>响应式布局实现 → rem/em 区别、媒体查询 → 其他常见布局实现 → 居中</p></li><li><p>BFC原理 → 如何创建 → 应用场景</p></li><li><p>移动端像素知识与viewport知识</p></li><li><p>sass/less特性、区别 → 怎么自己封装样式库 → css-loader/style-loader区别</p></li></ul><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ul><li><p>作用域、原型链、闭包、继承、类型判断、V8 GC</p></li><li><p>基础API、ES6/7/8新特性 → babel原理</p></li><li><p>函数式编程、高阶函数、柯里化、递归、模块化</p></li><li><p>DOM操作、事件流、事件方法</p></li></ul><blockquote><p>PS: 异步单独拿出来列一下</p></blockquote><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><ul><li><p>promise解决了什么问题、实现原理、使用场景</p></li><li><p>promise.all 概念、 怎么实现 → 用promise实现请求并发个数限制 → 希望即使前一个异步操作失败，也不要中断后面的异步操作，应该怎么做</p></li><li><p>说说async/await、generator → co.js 实现 → 三者对比，什么情况一定要用promise</p></li><li><p>说说JS异步编程 → JS事件循环、宏任务/微任务 → 说说react的setState → 说说node.js里的同步异步</p></li></ul><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ul><li><p>vue2的数据响应式原理 → vue2的缺陷、业务代码里面怎么处理、$set原理、怎么重写数组方法的、vue3怎么实现的、proxy优缺点、怎么处理vue3不支持IE → vue3了解哪些API → vue3做了哪些优化</p></li><li><p>生命周期 → 使用场景</p></li><li><p>组件data为什么是一个函数 → 工厂函数 → 构造函数 → new一个对象发生了什么</p></li><li><p>vue组件通信 → vuex原理</p></li><li><p>路由模式、实现原理 → 导航守卫 → 权限控制怎么做（页面和接口）→ 鉴权token</p></li><li><p>$nextTick 作用、实现原理 → 宏任务/微任务、 JS事件循环</p></li><li><p>key的作用 → diff算法思路、和react的区别</p></li><li><p>computed、watch 实现原理、区别、使用场景 → 说出三种watcher的区别</p></li><li><p>keep-alive 原理、使用场景</p></li><li><p>scoped 原理 → 如何改变第三方组件样式</p></li><li><p>组件封装有哪些思考</p></li></ul><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><ul><li><p>构建流程、实现原理 → loader、plugin用到了哪些及其作用 → webpack5新特性 → 与vite的区别</p></li><li><p>tree-shaking 原理、做过哪些相关优化</p></li><li><p>热更新原理</p></li><li><p>打包速度和体积分别做过哪些优化</p></li></ul><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><ul><li><p>说说浏览器页面加载过程 → 浏览器缓存 → 服务端渲染 → 跨域问题 → axios/fetch区别、做过哪些二次封装 → HTTP方法、状态码、HTTP1/HTTP2/HTTP3/HTTPS区别</p></li><li><p>xss/csrf原理、如何防御</p></li><li><p>做过哪些性能优化</p></li></ul><p><strong>像一些手写代码/算法题就不列举了，主要是提供一个大概的思路，可以按这个方向把自己的知识过一遍。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021影视记录</title>
      <link href="2021/07/15/2021%E5%BD%B1%E8%A7%86%E8%AE%B0%E5%BD%95/"/>
      <url>2021/07/15/2021%E5%BD%B1%E8%A7%86%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="2021-已看电影"><a href="#2021-已看电影" class="headerlink" title="2021 已看电影"></a>2021 已看电影</h2><h4 id="《盗梦空间》（五星好评）"><a href="#《盗梦空间》（五星好评）" class="headerlink" title="《盗梦空间》（五星好评）"></a>《盗梦空间》（五星好评）</h4><h4 id="《猫鼠游戏》"><a href="#《猫鼠游戏》" class="headerlink" title="《猫鼠游戏》"></a>《猫鼠游戏》</h4><h4 id="《禁闭岛》"><a href="#《禁闭岛》" class="headerlink" title="《禁闭岛》"></a>《禁闭岛》</h4><h4 id="《看不见的客人》（五星好评）"><a href="#《看不见的客人》（五星好评）" class="headerlink" title="《看不见的客人》（五星好评）"></a>《看不见的客人》（五星好评）</h4><h4 id="《隧道尽头》"><a href="#《隧道尽头》" class="headerlink" title="《隧道尽头》"></a>《隧道尽头》</h4><h4 id="《致命魔术》"><a href="#《致命魔术》" class="headerlink" title="《致命魔术》"></a>《致命魔术》</h4><h4 id="《蝴蝶效应》"><a href="#《蝴蝶效应》" class="headerlink" title="《蝴蝶效应》"></a>《蝴蝶效应》</h4><h4 id="《七宗罪》"><a href="#《七宗罪》" class="headerlink" title="《七宗罪》"></a>《七宗罪》</h4><h4 id="《致命ID》"><a href="#《致命ID》" class="headerlink" title="《致命ID》"></a>《致命ID》</h4><h4 id="《7号房的礼物》"><a href="#《7号房的礼物》" class="headerlink" title="《7号房的礼物》"></a>《7号房的礼物》</h4><h4 id="《超脱》"><a href="#《超脱》" class="headerlink" title="《超脱》"></a>《超脱》</h4><h4 id="《第六感》"><a href="#《第六感》" class="headerlink" title="《第六感》"></a>《第六感》</h4><h4 id="《消失的爱人》"><a href="#《消失的爱人》" class="headerlink" title="《消失的爱人》"></a>《消失的爱人》</h4><h4 id="《阳光姐妹淘》"><a href="#《阳光姐妹淘》" class="headerlink" title="《阳光姐妹淘》"></a>《阳光姐妹淘》</h4><h4 id="《记忆大师》"><a href="#《记忆大师》" class="headerlink" title="《记忆大师》"></a>《记忆大师》</h4><h4 id="《利刃出鞘》"><a href="#《利刃出鞘》" class="headerlink" title="《利刃出鞘》"></a>《利刃出鞘》</h4><h4 id="《逃出循环》"><a href="#《逃出循环》" class="headerlink" title="《逃出循环》"></a>《逃出循环》</h4><h4 id="《网络谜踪》"><a href="#《网络谜踪》" class="headerlink" title="《网络谜踪》"></a>《网络谜踪》</h4><h4 id="《恐怖游轮》"><a href="#《恐怖游轮》" class="headerlink" title="《恐怖游轮》"></a>《恐怖游轮》</h4><blockquote><p>PS：周末在家和小姐妹/同事一起看的电影，基本都是从豆瓣TOP250或者高分悬疑片挑的</p></blockquote><h2 id="2021-已刷综艺"><a href="#2021-已刷综艺" class="headerlink" title="2021 已刷综艺"></a>2021 已刷综艺</h2><h4 id="《吐槽大会》"><a href="#《吐槽大会》" class="headerlink" title="《吐槽大会》"></a>《吐槽大会》</h4><h4 id="《令人心动的offer》"><a href="#《令人心动的offer》" class="headerlink" title="《令人心动的offer》"></a>《令人心动的offer》</h4><p>刷了第二季、第三季</p><h4 id="《初入职场的我们》"><a href="#《初入职场的我们》" class="headerlink" title="《初入职场的我们》"></a>《初入职场的我们》</h4><p>看了一大半，弃了</p><h4 id="《听姐说》"><a href="#《听姐说》" class="headerlink" title="《听姐说》"></a>《听姐说》</h4><p>女明星毕竟不是专业的脱口秀演员，卖力是一回事，质量是另一回事≖ہ≖<br>看了一半，弃了</p><h4 id="《五十公里桃花坞》"><a href="#《五十公里桃花坞》" class="headerlink" title="《五十公里桃花坞》"></a>《五十公里桃花坞》</h4><p>大型社交现场，但没啥意思≖ہ≖<br>看了一半，弃了</p><h4 id="《心动的信号》第四季"><a href="#《心动的信号》第四季" class="headerlink" title="《心动的信号》第四季"></a>《心动的信号》第四季</h4><p>2倍速刷一下，观后感：</p><p>1 第一眼就基本能确定有没有可能了，毕竟每个人都有自己的审美~<br>2 可选择范围真太小了，若都没看对眼，这节目就挺没意思了，不过观察人类还是有点意思，所以断断续续追更一下<br>3 吐槽一下侦探团真是太水了</p><h4 id="《上班啦妈妈》"><a href="#《上班啦妈妈》" class="headerlink" title="《上班啦妈妈》"></a>《上班啦妈妈》</h4><p>这部综艺看的比较快，一两天时间刷了下，就以下一些感觉吧</p><p>1 其实面试几分钟就能看出一个人大概性格和水平了，所以就如何才能面试成功这个问题我们倒推一下，不外乎两点了，天赋和努力，这两个东西决定了你的基本盘，再加上一点运气和性格加成，你的面试结果也能被推测的八九不离十了。<br>再延展一下到我们自身，具体应该怎么做：首先就天赋来说，这个东西有就是有，没有就是没有，只能说最好选择自己擅长且感兴趣的职业吧，选对了路很重要；其次就努力来说，最好是有拿得出手的作品，有过硬的对口的专业经验，且对这次面试有充分的准备，对这家公司做过全面的调研；再者就是性格，或者说人格魅力，或者说情商，这个东西也很重要，在你前两者都不够出彩的情况下，这就是你能打的点了，当然性格这东西很难改变，也见仁见智，能改变的幅度比较小。<br>综上三点，就我们普通人来说，能见效显著的就是努力了，做长时间的、各方面的努力，是很有必要的。</p><p>2 每个人都有强项和弱项，在每个限定的场景里，你能发挥的其实很有限。比如在需要创意的时候，一个创作型人才能给出更多新颖的idea，在需要带领团队的时候，一个有领导能力的人又会比较出彩，没有人会一直第一，重要的是放平心态，该你发挥的时候就好好发挥，不擅长的可以试着去做，但不需要因此完全否定自己，有挫败感是正常的，能排解消化这种情绪也是一个成年人要学会的。</p><p>3 看广告公司那一段有感：对于给出的很多考题，如何做才能做到最好？第一是理解能力和分析能力，精准的理解和剖析考题需求，知道重点在哪里，这里包括，询问清楚各类相关需求，能够站在对方立场想问题等等；第二是方案的完善程度要尽可能高，可落地性强；第三是方案的创意性要足，要能够眼前一亮。当然还有其他能打的点，比如能够引起共鸣、打动人心等等。</p><h2 id="2021-已刷电视剧"><a href="#2021-已刷电视剧" class="headerlink" title="2021 已刷电视剧"></a>2021 已刷电视剧</h2><h4 id="《无罪之最》"><a href="#《无罪之最》" class="headerlink" title="《无罪之最》"></a>《无罪之最》</h4><h4 id="《禁忌女孩》"><a href="#《禁忌女孩》" class="headerlink" title="《禁忌女孩》"></a>《禁忌女孩》</h4><h4 id="《致命女人》第二季"><a href="#《致命女人》第二季" class="headerlink" title="《致命女人》第二季"></a>《致命女人》第二季</h4><h4 id="《爱上特种兵》"><a href="#《爱上特种兵》" class="headerlink" title="《爱上特种兵》"></a>《爱上特种兵》</h4><p>完全是磕男女主的颜才刷的，两三天刷完，剧情狗血就不说了，当下饭剧或打发下时间，两倍速加跳着看还是勉强可以刷一下。</p><h4 id="《叛逆者》"><a href="#《叛逆者》" class="headerlink" title="《叛逆者》"></a>《叛逆者》</h4><p>王阳的演技还挺不错，“拽王”这个称号实至名归，好喜欢他一副很拽欠打的表情啊哈哈，可惜角色有点虎头蛇尾，结局太惨淡。<br>通过这部剧才对朱一龙的脸有点印象，这个发型挺适合他的，然后乖乖的学生角色这种也挺适合嗯。</p>]]></content>
      
      
      <categories>
          
          <category> 影视记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影视记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记</title>
      <link href="2021/05/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/05/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>通过学习如何【组合输入信息】来对从未见过的数据做出有用的【预测】</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>标签： 要预测的事物<br>特征： 输入变量<br>样本： 特定实例 （分为有标签样本和无标签样本）<br>模型： 定义特征与标签的关系<br>训练： 创建或学习模型 （通过有标签样本学习）<br>推断： 将训练后的模型应用于无标签样本<br>损失： 是一个数值，表示对于单个样本而言模型预测的准确程度。<br>平方损失：一种常见的损失函数  (y - y’)2<br>均方误差 (MSE) ：每个样本的平均平方损失。要计算 MSE，请求出各个样本的所有平方损失之和，然后除以样本数量。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.bmp.ovh/imgs/2021/05/dda2acd1c2ce6e07.png" alt="pic"></p><h4 id="如何降级损失"><a href="#如何降级损失" class="headerlink" title="如何降级损失"></a>如何降级损失</h4><p>迭代试错<br>梯度下降法/随机梯度下降法<br>优化学习速率/步长</p><h4 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h4><p>过拟合模型在训练过程中产生的损失很低，但在预测新数据方面的表现却非常糟糕。</p><h4 id="奥卡姆剃刀定律"><a href="#奥卡姆剃刀定律" class="headerlink" title="奥卡姆剃刀定律"></a>奥卡姆剃刀定律</h4><p>机器学习模型越简单，良好的实证结果就越有可能不仅仅基于样本的特性。</p><h4 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h4><p>1.随机抽取独立同分布 (i.i.d) 的样本，即样本之间不会互相影响<br>2.分布是平稳的；即分布在数据集内不会发生变化<br>3.从同一分布的数据划分中抽取样本</p><h4 id="训练集"><a href="#训练集" class="headerlink" title="训练集"></a>训练集</h4><p>用于训练模型的子集</p><h4 id="测试集"><a href="#测试集" class="headerlink" title="测试集"></a>测试集</h4><p>用于测试训练后模型的子集<br>1.规模足够大，可产生具有统计意义的结果。<br>2.能代表整个数据集。换言之，挑选的测试集的特征应该与训练集的特征相同。<br>ps: 请勿对测试数据进行训练</p><h4 id="验证集"><a href="#验证集" class="headerlink" title="验证集"></a>验证集</h4><p>使用验证集评估训练集的效果</p><h4 id="更好的工作流程"><a href="#更好的工作流程" class="headerlink" title="更好的工作流程"></a>更好的工作流程</h4><p>使用训练集训练模型 -&gt; 使用验证集评估模型 -&gt; 根据在验证集上获得的效果调整模型 -&gt; 选择获得最佳效果的模型 -&gt; 使用测试集确认模型的效果</p><h4 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h4><p>将原始数据转换为特征矢量</p><h4 id="良好的特征值"><a href="#良好的特征值" class="headerlink" title="良好的特征值"></a>良好的特征值</h4><p>1.在数据集中出现大约 5 次以上<br>2.具有清晰明确的含义<br>3.实际数据内不掺入特殊值<br>4.特征的定义不应随时间发生变化</p><h4 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h4><p>缩放特征值<br>处理极端离群值</p><h4 id="特征组合"><a href="#特征组合" class="headerlink" title="特征组合"></a>特征组合</h4><p>通过将两个或多个输入特征相乘来对特征空间中的非线性规律进行编码的合成特征</p><h4 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h4><p>通过降低复杂模型的复杂度来防止过拟合<br>也就是说，以最小化损失和复杂度为目标（这称为结构风险最小化）</p><h4 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h4><p>一种极其高效的概率计算机制<br>返回的是概率（按原样/转换成二元类别）</p><blockquote><p>1 线性回归的损失函数是平方损失。逻辑回归的损失函数是对数损失函数<br>2 “调整”逻辑回归的阈值不同于调整学习速率等超参数。在选择阈值时，需要评估您将因犯错而承担多大的后果</p></blockquote><h4 id="准确率-精确率-召回率"><a href="#准确率-精确率-召回率" class="headerlink" title="准确率 精确率 召回率"></a>准确率 精确率 召回率</h4><p>TP = 真正例，TN = 真负例，FP = 假正例，FN = 假负例<br>Accuracy（准确率）= TP + TN / ( TP + TN + FP + FN )<br>Precision（精确率）= TP / ( TP + FP )<br>Recall（召回率/真正例率）= TP / ( TP + FN )<br>FPR（假正例率）= FP / （FP + TN）</p><h4 id="ROC-曲线"><a href="#ROC-曲线" class="headerlink" title="ROC 曲线"></a>ROC 曲线</h4><p>用于绘制采用不同分类阈值时的 TPR 与 FPR。降低分类阈值会导致将更多样本归为正类别，从而增加假正例和真正例的个数。</p><h4 id="ROC-曲线下面积"><a href="#ROC-曲线下面积" class="headerlink" title="ROC 曲线下面积"></a>ROC 曲线下面积</h4><p>对所有可能的分类阈值的效果进行综合衡量。<br>看作模型将某个随机正类别样本排列在某个随机负类别样本之上的概率。</p><h4 id="预测偏差"><a href="#预测偏差" class="headerlink" title="预测偏差"></a>预测偏差</h4><p>预测偏差 = 预测平均值 - 数据集中相应标签的平均值</p><h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><ul><li>一组节点，类似于神经元，位于层中。</li><li>一组权重，表示每个神经网络层与其下方的层之间的关系。下方的层可能是另一个神经网络层，也可能是其他类型的层。</li><li>一组偏差，每个节点一个偏差。</li><li>一个激活函数，对层中每 个节点的输出进行转换。不同的层可能拥有不同的激活函数。</li></ul><h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><p>将大型稀疏矢量映射到一个保留语义关系的低维空间。</p><h4 id="偏差类型"><a href="#偏差类型" class="headerlink" title="偏差类型"></a>偏差类型</h4><p>报告偏差、自动化偏差、选择偏差、群体归因偏差、隐性偏差</p><h4 id="识别偏差"><a href="#识别偏差" class="headerlink" title="识别偏差"></a>识别偏差</h4><p>特征值缺失、异常特征值、数据倾斜</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带你了解字符编码的前世今生</title>
      <link href="2019/04/29/%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>2019/04/29/%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1946-计算机诞生"><a href="#1946-计算机诞生" class="headerlink" title="1946 计算机诞生"></a>1946 计算机诞生</h2><p>1946 年，世界第一台计算机诞生了。计算机由硬件和系统软件组成，它最基本的功能就是存储、表示与处理信息。通俗地说，信息其实就是由各种各样的字符组成，比如英文字母、汉字以及其他国家的语言等。那么计算机如何才能表示这些各种各样的字符呢？</p><p>于是有一群人想到，我们可以用8个晶体管的“通”或“断”组合出一些不同的状态，来表示信息。“通”用 1 表示，“断”用 0 表示，这样一个由值 0 和 1 组成的长度为 8 的位序列，就代表着一个字节，八个二进制位可以组合出 256 种状态，这样一个字节就可以表示 256 种字符。</p><h2 id="1967-ASCII"><a href="#1967-ASCII" class="headerlink" title="1967 ASCII"></a>1967 ASCII</h2><p>计算机最先只在美国使用，他们把所有的空格、标点符号、数字、大小写字母分别用单个字节表示，一直编到了第128个，这样计算机就可以用不同字节来存储英语的文字了，于是美国制定了一套 ASCII 编码标准，用来规定这种英语字符与二进制位之间的关系。</p><p>这种方式就是用一个唯一的单字节大小的整数值来表示每个字符。ASCII 码一共规定了 128 个字符的编码，这 128 个符号，只占用了一个字节的后面 7 位，最前面的一位统一规定为 0。比如空格 SPACE 是 32（二进制00100000），大写的字母A是65（二进制01000001）。</p><h2 id="EASCII"><a href="#EASCII" class="headerlink" title="EASCII"></a>EASCII</h2><p>后来，世界各地都开始使用计算机，128 个字符对于英语字符确实够用了，但用来表示其他语言就有些捉襟见肘了。比如法语中，字母上方有注音符号，于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。这样一来，这些欧洲国家的编码体系，可以表示最多 256 个字符了。因此 EASCII（Extended ASCII，延伸美国标准信息交换码）应运而生。下图是 EASCII 码比 ASCII 码扩充出来的符号包括表格符号、计算符号、希腊字母和特殊的拉丁符号:</p><h2 id="1981-GB2312"><a href="#1981-GB2312" class="headerlink" title="1981 GB2312"></a>1981 GB2312</h2><p>但是等计算机发展到中国，256种符号用来表示我们这10万左右的汉字就远远不够了，单个字节不够，我们就用两个字节组合起来表示呀，于是我们规定，一个小于 127 的字符的意义与原来相同，但两个大于 127 的字符连在一起时，就表示一个汉字，前面的一个字节（称之为高字节）从 0xA1 用到 0xF7，后面一个字节（称之为低字节）从 0xA1 用到 0Xfe，这样我们可以组合出大约 7000 多个简体汉字了。</p><p>于是 1981 年，国家标准化管理委员会正式制订了中华人民共和国国家标准简体中文字符集，全称《信息交换用汉字编码字符集·基本集》，项目代号为 GB 2312。</p><h2 id="1984-BIG5"><a href="#1984-BIG5" class="headerlink" title="1984 BIG5"></a>1984 BIG5</h2><p>但是又考虑到港澳台同胞使用的繁体字并没有收录到GB2312编码，于是信息工业策进会在1984年与台湾13家厂商签定“16位个人电脑套装软件合作开发（BIG-5）计划”，开始编写并推出了BIG5标准。</p><h2 id="1991-Unicode"><a href="#1991-Unicode" class="headerlink" title="1991 Unicode"></a>1991 Unicode</h2><p>随着计算机的飞速发展，各个国家都开始制定自己的编码标准，这样导致了国家之间谁也不懂别人的编码，不支持别人的编码，这时候要是将全世界所有的字符包含在一个集合里，有一个统一的字符集就好了，就不会再有乱码的问题。</p><p>于是有两个组织都开始研究这件事，1984 年 ISO/IEC 小组成立，随后 1988 年统一码联盟成立，后来他们发现各自在做相同的工作，于是两个组织决定合并字符集。国际组织因此发行了一个全球统一编码表，把全球各国文字都统一在一个编码标准里，名为 Unicode。1991 年，两个组织共同的工作成果 Unicode 1.0 正式发布，不过 Unicode 1.0 并不包含  CJK 字符（即中日韩）。</p><h2 id="1993-UCS"><a href="#1993-UCS" class="headerlink" title="1993 UCS"></a>1993 UCS</h2><p>1993 年，ISO/IEC 小组发表了 ISO/IEC 10646 标准，ISO 10646 标准中定义的字符集为 UCS。UCS 是一个超大的字符集，它有两种编码方案：UCS-2 和UCS-4，Unicode 默认以 UCS-2 编码。</p><p>我们可以把 Unicode 看作是一个标准或组织，而 UCS 就是一个字符集，那么 UCS 在网络中的传输标准就是 UTF 。UTF 是Unicode Transformation Format 的缩写，中文译作 Unicode 转换格式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示）。</p><h2 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h2><p>UTF-32的编码方法是，每个码点使用四个字节表示，字节内容一一对应码点。比如：</p><p>U+0000 = 0x0000 0000</p><p>U+597D = 0x0000 597D</p><p>UTF-32 的优点在于，转换简单直观，查找效率高，时间复杂度只为 O(1)。缺点在于浪费空间，同样内容的英语文本，它会比 ASCII 编码大四倍。所以不推荐使用这种编码方法，HTML 5 标准就明文规定，网页不得编码成 UTF-32。</p><h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它使用 1~4 个字节表示一个符号，根据不同的符号而变化字节长度。这样对于存储来说并没有造成极大的浪费，节省了许多空间。</p><p>UTF-8 的编码规则有二条：</p><p>1）对于单字节的符号，字节的第一位设为 0，后面 7 位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p><p>2）对于 n 字节的符号（n &gt; 1），第一个字节的前n 位都设为 1，第 n + 1 位设为 0，后面字节的前两位一律设为 10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p><p>如此一来：</p><ul><li>   128 个 ASCII 字符只需一个字节编码（Unicode 范围由 U+0000 至 U+007F）</li><li>   拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母需要二个字节编码（Unicode 范围由 U+0080 至 U+07FF）</li><li>   大部分国家的常用字（包括中文）使用三个字节编码</li><li>   其他极少使用的生僻字符使用四字节编码</li></ul><p>例如，希伯来语字母 aleph（א）的 Unicode 代码是 U+05D0，按照以下方法改成 UTF-8：</p><ol><li>   它属于 U+0080 到 U+07FF 区域，说明它使用双字节，110yyyyy 10zzzzzz.</li><li>   十六进制的 0x05D0 换算成二进制就是 101-1101-0000.</li><li>   这 11 位数按顺序放入”y”部分和”z”部分：11010111 10010000.</li><li>   最后结果就是双字节，用十六进制写起来就是 0xD7 0x90，这就是字符 aleph（א）的 UTF-8 编码。</li></ol><h2 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h2><p>UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。长度为 2 个字节（基本平面：U+0000 到 U+FFFF）或 4 个字节（辅助平面：U+010000 到 U+10FFFF）。128 个 ASCII 字符需两个字节编码，而其他字符使用四个字节编码。<br>当我们要转成 UTF-16 的时候，首先区分这是基本平面字符，还是辅助平面字符。如果是前者，直接将码点转为对应的十六进制形式，长度为两字节。比如 U+597D = 0x597D。如果是辅助平面字符，则根据转码公式进行计算。</p><p>作为逻辑意义上的 UTF-16 编码（码元序列），由于历史的原因，在映射为物理意义上的字节序列时，分为 UTF-16BE( Big Endian )、UTF-16LE( Little Endian )两种情况。比如，“ABC” 这三个字符的 UTF-16 编码（码元序列）为：00 41 00 42 00 43；其对应的各种字节序列如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://segmentfault.com/img/bVbrY7Z?w=1763&h=494" alt="clipboard.png"></p><p>Windows 平台下的 UTF-16 编码（即上述的FF FE 41 00 42 00 43 00） 默认为带有 BOM 的小端序（即Little Endian with BOM）。</p><blockquote><p><strong>Little endian 和 Big endian</strong><br>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用 FEFF 表示。这正好是两个字节，而且 FF 比 FE 大 1。<br>如果一个文本文件的头两个字节是 FE FF，就表示该文件采用大头方式；如果头两个字节是 FF FE，就表示该文件采用小头方式。</p></blockquote><blockquote><p><strong>BOM (Byte order Mark)</strong><br>Unicode 规范中推荐的标记字节顺序的方法是 BOM。它出现在文本文件头部，用于标识文件是采用哪种格式的编码。</p></blockquote><h2 id="1993-GB13000"><a href="#1993-GB13000" class="headerlink" title="1993 GB13000"></a>1993 GB13000</h2><p>1993 年，包含 CJK 的 Unicode 1.1 已经发布了，于是在同一年，中国大陆制定了 GB13000.1-93 国家编码标准（简称 GB13000）。此标准等同于 ISO/IEC 10646.1:1993 和 Unicode 1.1。</p><h2 id="1995-GBK"><a href="#1995-GBK" class="headerlink" title="1995 GBK"></a>1995 GBK</h2><p>随着个人计算机在中国的流行，微软开始意识到中国是一个巨大的市场，于是 1995 年，微软利用了 GB2312 中未使用的编码空间，收录了 GB13000 中的所有字符制定了汉字内码扩展规范 GBK。所以 GBK 是向下完全兼容 GB2312 的。</p><p>GBK 共收入 21886 个汉字和图形符号，包括：</p><ul><li>   GB 2312 中的全部汉字、非汉字符号。</li><li>   BIG5 中的全部汉字。</li><li>   与 ISO 10646 相应的国家标准 GB 13000 中的其它 CJK 汉字，以上合计 20902 个汉字。</li><li>   其它汉字、部首、符号，共计 984 个。<br>GBK 采用双字节表示，总体编码范围为 8140-FEFE 之间，首字节在 81-FE 之间，尾字节在 40-FE 之间，剔除 XX7F 一条线。GBK 编码区分三部分：汉字区、图形符号区、用户自定义区。</li></ul><h2 id="2000-GB18030"><a href="#2000-GB18030" class="headerlink" title="2000 GB18030"></a>2000 GB18030</h2><p>考虑到 GBK 只包含了大部分的汉字和繁体字等，我们的少数民族的自己的汉字并没有考虑在内，于是在 2000 年，电子工业标准化研究所起草了 GB18030 标准，项目代号 “GB 18030-2000”，全称《信息技术-信息交换用汉字编码字符集-基本集的扩充》。该标准收录了27484个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。</p>]]></content>
      
      
      <categories>
          
          <category> 字符编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
